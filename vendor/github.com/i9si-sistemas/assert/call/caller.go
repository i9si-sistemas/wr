package call

import (
	"fmt"
	"runtime"
	"strings"
	"unicode"
	"unicode/utf8"
)

var (
	funcForPC  = runtime.FuncForPC
	callerInfo = runtime.Caller
)

// Caller returns the file name and line number of the calling function,
// excluding autogenerated, testing, and certain function calls.
// It traverses the call stack to find the most relevant caller
// that matches the desired criteria.
//
// The returned string format is "filename:lineNumber". If no valid caller
// is found, it returns an empty string.
//
//	func TestFn(t *testing.T) {
//	    callerInfo := Caller()
//	    fmt.Println("Called from:", callerInfo)
//	}
func Caller() string {
	callers := []string{}
	for i := 0; ; i++ {
		pc, file, line, ok := callerInfo(i)
		if !ok {
			break
		}

		if file == "<autogenerated>" {
			break
		}

		f := funcForPC(pc)
		if f == nil {
			break
		}
		name := f.Name()

		if name == "testing.tRunner" {
			break
		}

		parts := strings.Split(file, "/")
		if len(parts) > 1 {
			callers = append(callers, fmt.Sprintf("%s:%d", file, line))
		}

		segments := strings.Split(name, ".")
		name = segments[len(segments)-1]
		if hasPrefix(name, "Test") || hasPrefix(name, "Benchmark") || hasPrefix(name, "Example") {
			break
		}
	}
	if len(callers) > 0 {
		return callers[len(callers)-1]
	}
	return ""
}

func hasPrefix(name, prefix string) bool {
	if !strings.HasPrefix(name, prefix) {
		return false
	}
	if len(name) == len(prefix) {
		return true
	}
	r, _ := utf8.DecodeRuneInString(name[len(prefix):])
	return !unicode.IsLower(r)
}
